# Merge Overlapping Intervals

## Problem Statement

Given an array of **N intervals**, merge all **overlapping intervals** and return the minimum number of non-overlapping intervals.

### What is an Interval?

**Interval:** A pair [start, end] representing a range

**Example:** [1, 3] means starts at 1, ends at 3

### What is Overlapping?

Two intervals overlap if they share at least one common point.

```
[1, 3] and [2, 6]:
  1 -------- 3
      2 ------------ 6
      ↑_____↑
      Overlap!

[8, 10] and [9, 11]:
  8 -------- 10
          9 ------- 11
          ↑____↑
          Overlap!

[1, 3] and [8, 10]:
  1 ---- 3
                8 ----- 10
  No overlap!
```

### Example

**Input:** [[1,3], [2,6], [8,9], [9,11], [8,10], [2,4], [15,18], [16,17]]

**Visual Representation:**
```
Number Line:
1       3                     8  9    11          15       18
|-------|                     |--|    |           |--------|
    2----------6              |--------|          |------|
    |---------|               8--------10         16--17
                              
Merged:
1----------6                  8---------11        15-------18
```

**Output:** [[1,6], [8,11], [15,18]]

**Explanation:**
- [1,3], [2,6], [2,4] merged into [1,6]
- [8,9], [9,11], [8,10] merged into [8,11]
- [15,18], [16,17] merged into [15,18]

---

## Why Not Merge All Into One?

**Question:** Why not merge everything into [1, 18]?

**Answer:** There are **gaps** (empty spaces):
```
[1,6]       gap      [8,11]    gap    [15,18]
  └─────────────────┘  └──────────────┘

If we use [1,18], we include empty ranges [7,7] and [12,14]
```

**Goal:** Find **minimum** number of intervals that cover all points with **no empty spaces**.

---

## Approach 1: Brute Force

### Key Idea

1. **Sort intervals** to keep similar intervals together
2. **Iterate and expand** intervals to accommodate overlapping ones

### Algorithm

**Step 1:** Sort intervals by start time
```
Original: [[1,3], [2,6], [8,9], [9,11], [8,10], [2,4], [15,18], [16,17]]

Sorted:   [[1,3], [2,4], [2,6], [8,9], [8,10], [9,11], [15,18], [16,17]]
```

**Step 2:** For each interval, try to merge with subsequent intervals

**How to check overlap?**
```
Current interval: [start, end]
Next interval:    [nextStart, nextEnd]

Overlapping if: nextStart <= end
```

### Detailed Walkthrough

**Sorted:** [[1,3], [2,4], [2,6], [8,9], [8,10], [9,11], [15,18], [16,17]]

**Iteration 1:** Start with [1,3]
```
Current: [1, 3]

Check [2,4]:
- 2 <= 3? Yes, overlapping!
- Merge: [1, max(3,4)] = [1, 4]

Check [2,6]:
- 2 <= 4? Yes, overlapping!
- Merge: [1, max(4,6)] = [1, 6]

Check [8,9]:
- 8 <= 6? No, not overlapping!
- BREAK (no need to check further)

Result: [1, 6]
```

**Iteration 2:** Move to [2,4]
```
Check: 4 <= 6? (already covered by [1,6])
- Already part of previous interval
- Skip
```

**Iteration 3:** Move to [2,6]
```
Check: 6 <= 6? (already covered by [1,6])
- Already part of previous interval
- Skip
```

**Iteration 4:** Move to [8,9]
```
Current: [8, 9]

Check [8,10]:
- 8 <= 9? Yes, overlapping!
- Merge: [8, max(9,10)] = [8, 10]

Check [9,11]:
- 9 <= 10? Yes, overlapping!
- Merge: [8, max(10,11)] = [8, 11]

Check [15,18]:
- 15 <= 11? No, not overlapping!
- BREAK

Result: [8, 11]
```

**Iteration 5-6:** [8,10] and [9,11] already covered

**Iteration 7:** Move to [15,18]
```
Current: [15, 18]

Check [16,17]:
- 16 <= 18? Yes, overlapping!
- Merge: [15, max(18,17)] = [15, 18]
- Note: 18 already larger, no change

Result: [15, 18]
```

**Final Answer:** [[1,6], [8,11], [15,18]]

### Code

```java
import java.util.*;

public class Solution {
    public int[][] mergeBruteForce(int[][] intervals) {
        int n = intervals.length;
        
        // Step 1: Sort intervals by start time
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        List<int[]> answer = new ArrayList<>();
        
        // Step 2: For each interval
        for(int i = 0; i < n; i++) {
            int start = intervals[i][0];
            int end = intervals[i][1];
            
            // Check if already part of previous interval
            if(!answer.isEmpty() && end <= answer.get(answer.size()-1)[1]) {
                continue;  // Skip
            }
            
            // Try to merge with subsequent intervals
            for(int j = i+1; j < n; j++) {
                // Check overlap
                if(intervals[j][0] <= end) {
                    // Overlapping, expand end
                    end = Math.max(end, intervals[j][1]);
                } else {
                    // Not overlapping, no point checking further
                    break;
                }
            }
            
            // Add merged interval
            answer.add(new int[]{start, end});
        }
        
        return answer.toArray(new int[answer.size()][]);
    }
}
```

### Complexity Analysis

**Time Complexity:** O(N log N) + O(2N) ≈ **O(N log N)**

**Breakdown:**
- Sorting: O(N log N)
- Nested loops: O(2N) 
  - Each interval touched at most twice
  - Once as current, once as candidate for merging
  - Example: [1,3] checked, then [2,4] checks if in [1,6], then [2,6] checks if in [1,6]

**Space Complexity:** O(N)
- Answer array: O(N) in worst case (no overlaps)

**Issue:** Still O(2N) for traversal - interviewer wants single pass!

---

## Approach 2: Optimal (Single Pass)

### Key Insight

**Instead of:**
- Standing at an interval and checking who can merge with me

**Do this:**
- Compare current interval with **last merged interval**
- Single pass through sorted array

### Algorithm

1. **Sort intervals** by start time
2. **Add first interval** to answer
3. **For each remaining interval:**
   - If it overlaps with last interval in answer → Extend last interval
   - Otherwise → Add as new interval

### How to Check Overlap?

```
Last interval in answer: [lastStart, lastEnd]
Current interval:        [start, end]

Overlapping if: start <= lastEnd
```

### Detailed Walkthrough

**Sorted:** [[1,3], [2,4], [2,6], [8,9], [8,10], [9,11], [15,18], [16,17]]

**Initialize:**
```
answer = []
```

**Process [1,3]:**
```
answer is empty → Add [1,3]
answer = [[1,3]]
```

**Process [2,4]:**
```
Current: [2,4]
Last in answer: [1,3]

Check: 2 <= 3? Yes, overlapping!
Extend: [1, max(3,4)] = [1,4]

answer = [[1,4]]
```

**Process [2,6]:**
```
Current: [2,6]
Last in answer: [1,4]

Check: 2 <= 4? Yes, overlapping!
Extend: [1, max(4,6)] = [1,6]

answer = [[1,6]]
```

**Process [8,9]:**
```
Current: [8,9]
Last in answer: [1,6]

Check: 8 <= 6? No, not overlapping!
Add new interval: [8,9]

answer = [[1,6], [8,9]]
```

**Process [8,10]:**
```
Current: [8,10]
Last in answer: [8,9]

Check: 8 <= 9? Yes, overlapping!
Extend: [8, max(9,10)] = [8,10]

answer = [[1,6], [8,10]]
```

**Process [9,11]:**
```
Current: [9,11]
Last in answer: [8,10]

Check: 9 <= 10? Yes, overlapping!
Extend: [8, max(10,11)] = [8,11]

answer = [[1,6], [8,11]]
```

**Process [15,18]:**
```
Current: [15,18]
Last in answer: [8,11]

Check: 15 <= 11? No, not overlapping!
Add new interval: [15,18]

answer = [[1,6], [8,11], [15,18]]
```

**Process [16,17]:**
```
Current: [16,17]
Last in answer: [15,18]

Check: 16 <= 18? Yes, overlapping!
Extend: [15, max(18,17)] = [15,18]
Note: No change since 18 >= 17

answer = [[1,6], [8,11], [15,18]]
```

**Final Answer:** [[1,6], [8,11], [15,18]]

### Complete Java Code

```java
import java.util.*;

public class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;
        if(n == 0) return new int[0][0];
        
        // Step 1: Sort by start time
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        List<int[]> answer = new ArrayList<>();
        
        // Step 2: Process each interval
        for(int i = 0; i < n; i++) {
            // If answer is empty OR current doesn't overlap with last
            if(answer.isEmpty() || intervals[i][0] > answer.get(answer.size()-1)[1]) {
                // Add new interval
                answer.add(intervals[i]);
            }
            else {
                // Overlapping - extend last interval's end
                answer.get(answer.size()-1)[1] = 
                    Math.max(answer.get(answer.size()-1)[1], intervals[i][1]);
            }
        }
        
        // Convert List to Array
        return answer.toArray(new int[answer.size()][]);
    }
    
    public static void main(String[] args) {
        Solution sol = new Solution();
        
        int[][] intervals = {
            {1,3}, {2,6}, {8,9}, {9,11}, 
            {8,10}, {2,4}, {15,18}, {16,17}
        };
        
        System.out.println("Input:");
        printIntervals(intervals);
        
        int[][] result = sol.merge(intervals);
        
        System.out.println("\nMerged:");
        printIntervals(result);
    }
    
    private static void printIntervals(int[][] intervals) {
        for(int[] interval : intervals) {
            System.out.print("[" + interval[0] + "," + interval[1] + "] ");
        }
        System.out.println();
    }
}
```

**Output:**
```
Input:
[1,3] [2,6] [8,9] [9,11] [8,10] [2,4] [15,18] [16,17] 

Merged:
[1,6] [8,11] [15,18]
```

### Complexity Analysis

**Time Complexity:** O(N log N) + O(N) = **O(N log N)**

**Breakdown:**
- Sorting: O(N log N)
- Single pass: O(N)
- Total: O(N log N) dominates

**Space Complexity:** O(N)
- Answer array: O(N) in worst case
- No overlaps → all N intervals stored

**Improvement:** O(2N) → O(N) for traversal (single pass!)

---

## Why Sorting is Essential

**Without Sorting:**
```
Input: [[8,10], [1,3], [2,6]]

Without sort:
- Start with [8,10]
- Check [1,3]: 1 <= 10? Yes, extend to [1,10]
- Check [2,6]: 2 <= 10? Yes, keep [1,10]
Result: [[1,10]] ❌ WRONG!

Correct: [[1,6], [8,10]]
```

**With Sorting:**
```
Input: [[8,10], [1,3], [2,6]]
Sorted: [[1,3], [2,6], [8,10]]

- Start with [1,3]
- Check [2,6]: 2 <= 3? Yes, extend to [1,6]
- Check [8,10]: 8 <= 6? No, add [8,10]
Result: [[1,6], [8,10]] ✓ CORRECT!
```

**Why?** Sorting ensures:
- Similar intervals are together
- We process in chronological order
- Can detect non-overlapping by checking start > lastEnd

---

## Understanding the Comparator

### Java Sorting for 2D Arrays

```java
Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
```

**What this does:**
- Sorts by **first element** (start time)
- If first elements equal, sorts by **second element** (end time)

**Example:**
```
Before: [[2,6], [1,3], [2,4], [8,9]]
After:  [[1,3], [2,4], [2,6], [8,9]]
                 ↑_____↑
                 Same start, sorted by end
```

### Alternative Comparator Syntax

```java
// Lambda expression
Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

// Method reference
Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));

// Manual comparison
Arrays.sort(intervals, (a, b) -> {
    if(a[0] != b[0]) return a[0] - b[0];
    return a[1] - b[1];
});
```

---

## Edge Cases

### Case 1: No Overlaps
```
Input: [[1,2], [3,4], [5,6]]
Output: [[1,2], [3,4], [5,6]]

No intervals merge, all remain separate
```

### Case 2: All Overlap
```
Input: [[1,10], [2,3], [4,5], [6,7]]
Output: [[1,10]]

All intervals within [1,10]
```

### Case 3: Identical Intervals
```
Input: [[1,3], [1,3], [1,3]]
Output: [[1,3]]

All merge into one
```

### Case 4: One Contains Another
```
Input: [[1,10], [2,3]]
Output: [[1,10]]

[2,3] completely inside [1,10]
```

### Case 5: Adjacent (Touching)
```
Input: [[1,3], [3,5]]
Output: [[1,5]]

3 <= 3 is true, so they merge
```

### Case 6: Single Interval
```
Input: [[1,5]]
Output: [[1,5]]

Nothing to merge
```

### Case 7: Two Non-Overlapping
```
Input: [[1,3], [5,7]]
Output: [[1,3], [5,7]]

Gap between them
```

---

## Common Mistakes

❌ **Mistake 1: Not sorting**
```java
// WRONG - doesn't sort first
public int[][] merge(int[][] intervals) {
    List<int[]> answer = new ArrayList<>();
    // ... process intervals
}
```
**Why wrong?** Order matters for detecting overlaps!

❌ **Mistake 2: Not using max when extending**
```java
// WRONG
if(intervals[i][0] <= lastEnd) {
    lastEnd = intervals[i][1];  // Just replace
}
```
**Why wrong?** New interval might be contained in last!
```
Last: [1,10], Current: [2,3]
If we replace: [1,3] ❌ WRONG!
Should be: [1,10] ✓
```

❌ **Mistake 3: Using < instead of <=**
```java
// WRONG
if(intervals[i][0] < lastEnd) {  // Should be <=
```
**Why wrong?** Touching intervals won't merge!
```
[1,3] and [3,5]: 3 < 3? No
Should merge to [1,5]!
```

❌ **Mistake 4: Modifying intervals array directly**
```java
// WRONG - modifying input
intervals[lastIndex][1] = newEnd;
```
**Why wrong?** May need original data, and answer needs new array!

✅ **Correct Approach:**
```java
Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
List<int[]> answer = new ArrayList<>();

for(int[] interval : intervals) {
    if(answer.isEmpty() || interval[0] > answer.get(answer.size()-1)[1]) {
        answer.add(interval);
    } else {
        answer.get(answer.size()-1)[1] = 
            Math.max(answer.get(answer.size()-1)[1], interval[1]);
    }
}

return answer.toArray(new int[answer.size()][]);
```

---

## Visualization of Algorithm

```
Sorted: [[1,3], [2,6], [8,9], [9,11], [15,18], [16,17]]

Step 1:
answer = []
Current: [1,3]
→ Empty, add [1,3]
answer = [[1,3]]

Step 2:
answer = [[1,3]]
         └─last
Current: [2,6]
→ 2 <= 3? Yes, extend
answer = [[1,6]]

Step 3:
answer = [[1,6]]
         └─last
Current: [8,9]
→ 8 <= 6? No, add new
answer = [[1,6], [8,9]]

Step 4:
answer = [[1,6], [8,9]]
                └─last
Current: [9,11]
→ 9 <= 9? Yes, extend
answer = [[1,6], [8,11]]

Step 5:
answer = [[1,6], [8,11]]
                 └─last
Current: [15,18]
→ 15 <= 11? No, add new
answer = [[1,6], [8,11], [15,18]]

Step 6:
answer = [[1,6], [8,11], [15,18]]
                          └─last
Current: [16,17]
→ 16 <= 18? Yes, extend (no change, max(18,17)=18)
answer = [[1,6], [8,11], [15,18]]
```

---

## Approach Comparison

| Approach | Time | Space | Passes |
|----------|------|-------|--------|
| Brute Force | O(N log N) + O(2N) | O(N) | 2 passes over data |
| Optimal | O(N log N) + O(N) | O(N) | 1 pass over data |

**Key Difference:** Single pass vs checking forward each time

---

## Key Takeaways

1. **Sorting is Essential**
   - Groups overlapping intervals together
   - Enables chronological processing

2. **Two Conditions for Merging:**
   - First condition: `answer.isEmpty()` → Add first interval
   - Second condition: `start > lastEnd` → Non-overlapping, add new
   - Otherwise: Overlapping, extend last

3. **Use Max When Extending:**
   - `lastEnd = max(lastEnd, currentEnd)`
   - Handles contained intervals

4. **Single Pass Efficiency:**
   - Only compare with last merged interval
   - No need to check all previous intervals

5. **Time Dominated by Sorting:**
   - Sorting: O(N log N)
   - Merging: O(N)
   - Total: O(N log N)

---

## Interview Tips

1. **Start with explanation:**
   - "Need to sort to group overlapping intervals"
   - "Then merge in single pass"

2. **Draw timeline:**
   - Visual representation helps interviewer

3. **Mention comparator:**
   - "Sort by start time using comparator"

4. **Explain overlap condition:**
   - "Two intervals overlap if current.start <= last.end"

5. **Handle edge cases:**
   - Empty array, single interval, no overlaps

6. **State complexity:**
   - "O(N log N) time from sorting"
   - "O(N) space for answer array"

This problem tests your ability to **use sorting** to simplify problems and **recognize greedy patterns**!