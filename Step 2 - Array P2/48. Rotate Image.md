# Rotate Matrix by 90 Degrees (Rotate Image)

## Problem Statement

Given an **N × N matrix** (square matrix), rotate it **clockwise by 90 degrees**.

### Example

**Input:**
```
1   2   3   4
5   6   7   8
9  10  11  12
13 14  15  16
```

**Output (After 90° clockwise rotation):**
```
13  9   5   1
14  10  6   2
15  11  7   3
16  12  8   4
```

**Constraint:** N × N square matrix

---

## Approach 1: Brute Force (Using Extra Matrix)

### Idea

1. Create a new **answer matrix** of size N × N
2. For each element at position (i, j), place it at its correct rotated position
3. Return the answer matrix

### Key Observation: Rotation Pattern

When rotating 90° clockwise, observe where each row goes:

```
Original Matrix:
Row 0: [1,  2,  3,  4]  → Goes to Last Column (column 3)
Row 1: [5,  6,  7,  8]  → Goes to 2nd Last Column (column 2)
Row 2: [9, 10, 11, 12]  → Goes to 3rd Last Column (column 1)
Row 3: [13,14, 15, 16]  → Goes to 4th Last Column (column 0)
```

**Pattern:** 
- Row 0 → Column 3 (n-1)
- Row 1 → Column 2 (n-2)
- Row 2 → Column 1 (n-3)
- Row i → Column (n-1-i)

### Finding the Formula

Let's trace where elements go:

```
Original Index → Rotated Index

(0,0): 1  → (0,3)
(0,1): 2  → (1,3)
(0,2): 3  → (2,3)
(0,3): 4  → (3,3)

(1,0): 5  → (0,2)
(1,1): 6  → (1,2)
(1,2): 7  → (2,2)
(1,3): 8  → (3,2)

(2,0): 9  → (0,1)
(2,1): 10 → (1,1)
(2,2): 11 → (2,1)
(2,3): 12 → (3,1)

(3,0): 13 → (0,0)
(3,1): 14 → (1,0)
(3,2): 15 → (2,0)
(3,3): 16 → (3,0)
```

**Observation:**
- For element at (i, j):
  - New row = j
  - New column = n-1-i

**Formula:** `matrix[i][j]` → `answer[j][n-1-i]`

### Verification

```
(0,0): 1  → answer[0][3] ✓
(0,1): 2  → answer[1][3] ✓
(1,0): 5  → answer[0][2] ✓
(2,3): 12 → answer[3][1] ✓
```

### Code

```java
public class Solution {
    public int[][] rotateMatrixBruteForce(int[][] matrix) {
        int n = matrix.length;
        int[][] answer = new int[n][n];
        
        // For each element in original matrix
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                // Place at rotated position
                answer[j][n-1-i] = matrix[i][j];
            }
        }
        
        return answer;
    }
}
```

### Complexity Analysis

**Time Complexity:** O(N²)
- Traversing entire N × N matrix
- Each element placed once

**Space Complexity:** O(N²)
- Using extra N × N answer matrix

**Verdict:** ❌ Interviewer asks to optimize space (do it in-place)

---

## Approach 2: Optimal (In-Place Rotation)

### Key Observation: Transpose + Reverse

**Observation 1:** Compare rotated matrix columns with original:

```
Original Matrix:
1   2   3   4
5   6   7   8
9  10  11  12
13 14  15  16

Rotated Matrix:
13  9   5   1  ← This is Column 0 REVERSED!
14  10  6   2  ← This is Column 1 REVERSED!
15  11  7   3  ← This is Column 2 REVERSED!
16  12  8   4  ← This is Column 3 REVERSED!
```

**Key Insight:**
- Original Column 0: [1, 5, 9, 13]  → Rotated Row 0: [13, 9, 5, 1]
- Original Column 1: [2, 6, 10, 14] → Rotated Row 1: [14, 10, 6, 2]
- Original Column 2: [3, 7, 11, 15] → Rotated Row 2: [15, 11, 7, 3]
- Original Column 3: [4, 8, 12, 16] → Rotated Row 3: [16, 12, 8, 4]

**Pattern:** Each column becomes a row, but **reversed**!

### Two-Step Solution

**Step 1: Transpose the Matrix**
- Convert columns to rows
- row ↔ column

**Step 2: Reverse Each Row**
- Reverse elements in each row

### Visual Walkthrough

**Original Matrix:**
```
1   2   3   4
5   6   7   8
9  10  11  12
13 14  15  16
```

**Step 1 - Transpose:**
```
Row becomes Column, Column becomes Row

Column 0 → Row 0: [1,  5,  9, 13]
Column 1 → Row 1: [2,  6, 10, 14]
Column 2 → Row 2: [3,  7, 11, 15]
Column 3 → Row 3: [4,  8, 12, 16]

Transposed Matrix:
1   5   9  13
2   6  10  14
3   7  11  15
4   8  12  16
```

**Step 2 - Reverse Each Row:**
```
Row 0: [1,  5,  9, 13] → [13,  9,  5,  1]
Row 1: [2,  6, 10, 14] → [14, 10,  6,  2]
Row 2: [3,  7, 11, 15] → [15, 11,  7,  3]
Row 3: [4,  8, 12, 16] → [16, 12,  8,  4]

Final Rotated Matrix:
13  9   5   1
14  10  6   2
15  11  7   3
16  12  8   4
```

---

## Understanding Transpose

### What is Transpose?

**Definition:** Swap rows with columns

```
Original:          Transposed:
1   2   3          1   4   7
4   5   6    →     2   5   8
7   8   9          3   6   9
```

**Formula:** `matrix[i][j]` ↔ `matrix[j][i]`

### How to Transpose In-Place?

**Observation 1: Diagonal Elements Stay**

```
Original:          Transposed:
1   2   3   4      1   5   9  13
5   6   7   8      2   6  10  14
9  10  11  12      3   7  11  15
13 14  15  16      4   8  12  16

Diagonal (stays):
(0,0): 1  → 1  ✓
(1,1): 6  → 6  ✓
(2,2): 11 → 11 ✓
(3,3): 16 → 16 ✓
```

**Observation 2: Elements Swap Across Diagonal**

```
     j=0  j=1  j=2  j=3
i=0   1    2    3    4
i=1   5    6    7    8
i=2   9   10   11   12
i=3  13   14   15   16

Swaps needed:
(0,1) ↔ (1,0):  2 ↔  5
(0,2) ↔ (2,0):  3 ↔  9
(0,3) ↔ (3,0):  4 ↔ 13
(1,2) ↔ (2,1):  7 ↔ 10
(1,3) ↔ (3,1):  8 ↔ 14
(2,3) ↔ (3,2): 12 ↔ 15
```

**Visual Pattern:**
```
×  = No swap (diagonal)
↔  = Swap needed

×   ↔   ↔   ↔
    ×   ↔   ↔
        ×   ↔
            ×
```

### Efficient Traversal

**Key Insight:** Only traverse **upper triangle** of matrix

```
For i = 0: j = 1 to 3
For i = 1: j = 2 to 3
For i = 2: j = 3 to 3
```

**General Formula:**
```
for i = 0 to n-2:        // Don't need last row
    for j = i+1 to n-1:  // Start from i+1 (upper triangle)
        swap(matrix[i][j], matrix[j][i])
```

**Why i+1?** To avoid:
- Swapping diagonal elements with themselves
- Swapping same pair twice

### Transpose Algorithm

```java
public void transpose(int[][] matrix) {
    int n = matrix.length;
    
    // Traverse upper triangle only
    for(int i = 0; i < n-1; i++) {
        for(int j = i+1; j < n; j++) {
            // Swap across diagonal
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
```

---

## Understanding Reverse Each Row

After transpose, we need to reverse each row.

### Example

```
Transposed Matrix:
1   5   9  13
2   6  10  14
3   7  11  15
4   8  12  16

Reverse Row 0: [1, 5, 9, 13] → [13, 9, 5, 1]
Reverse Row 1: [2, 6, 10, 14] → [14, 10, 6, 2]
Reverse Row 2: [3, 7, 11, 15] → [15, 11, 7, 3]
Reverse Row 3: [4, 8, 12, 16] → [16, 12, 8, 4]
```

### Reverse Algorithm (Two Pointer)

```java
public void reverseRow(int[] row) {
    int left = 0;
    int right = row.length - 1;
    
    while(left < right) {
        // Swap
        int temp = row[left];
        row[left] = row[right];
        row[right] = temp;
        
        left++;
        right--;
    }
}
```

**For entire matrix:**
```java
for(int i = 0; i < n; i++) {
    reverseRow(matrix[i]);
}
```

---

## Complete Java Code

```java
public class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        
        // Step 1: Transpose the matrix
        for(int i = 0; i < n-1; i++) {
            for(int j = i+1; j < n; j++) {
                // Swap across diagonal
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        // Step 2: Reverse each row
        for(int i = 0; i < n; i++) {
            reverseRow(matrix[i]);
        }
    }
    
    // Helper function to reverse a row
    private void reverseRow(int[] row) {
        int left = 0;
        int right = row.length - 1;
        
        while(left < right) {
            int temp = row[left];
            row[left] = row[right];
            row[right] = temp;
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        Solution sol = new Solution();
        
        int[][] matrix = {
            {1,  2,  3,  4},
            {5,  6,  7,  8},
            {9, 10, 11, 12},
            {13,14, 15, 16}
        };
        
        System.out.println("Original Matrix:");
        printMatrix(matrix);
        
        sol.rotate(matrix);
        
        System.out.println("\nRotated Matrix:");
        printMatrix(matrix);
    }
    
    private static void printMatrix(int[][] matrix) {
        for(int[] row : matrix) {
            for(int num : row) {
                System.out.printf("%3d ", num);
            }
            System.out.println();
        }
    }
}
```

**Output:**
```
Original Matrix:
  1   2   3   4 
  5   6   7   8 
  9  10  11  12 
 13  14  15  16 

Rotated Matrix:
 13   9   5   1 
 14  10   6   2 
 15  11   7   3 
 16  12   8   4
```

---

## Using Built-in Reverse (Alternative)

If your language has built-in array reverse:

```java
import java.util.Collections;

public void rotate(int[][] matrix) {
    int n = matrix.length;
    
    // Step 1: Transpose
    for(int i = 0; i < n-1; i++) {
        for(int j = i+1; j < n; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    
    // Step 2: Reverse each row
    for(int i = 0; i < n; i++) {
        // Convert array to list, reverse, and copy back
        // OR use two-pointer approach as shown above
        reverseArray(matrix[i]);
    }
}

private void reverseArray(int[] arr) {
    int left = 0, right = arr.length - 1;
    while(left < right) {
        int temp = arr[left];
        arr[left++] = arr[right];
        arr[right--] = temp;
    }
}
```

---

## Complexity Analysis

### Step 1: Transpose

```java
for(int i = 0; i < n-1; i++) {
    for(int j = i+1; j < n; j++) {
        swap(matrix[i][j], matrix[j][i]);
    }
}
```

**Iterations:**
- i=0: j runs from 1 to n-1 → (n-1) swaps
- i=1: j runs from 2 to n-1 → (n-2) swaps
- i=2: j runs from 3 to n-1 → (n-3) swaps
- ...
- i=n-2: j runs from n-1 to n-1 → 1 swap

**Total:** (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ **N²/2**

### Step 2: Reverse Each Row

```java
for(int i = 0; i < n; i++) {
    reverseRow(matrix[i]);  // O(n/2) per row
}
```

**Iterations:** n rows × (n/2) swaps = **N²/2**

### Total Complexity

**Time Complexity:** O(N²/2) + O(N²/2) = **O(N²)**

**Space Complexity:** O(1)
- In-place modification
- Only using temporary variables for swapping

---

## Step-by-Step Dry Run

**Original Matrix:**
```
1   2   3
4   5   6
7   8   9
```

### Step 1: Transpose

**Iteration (i=0, j=1):** Swap (0,1) ↔ (1,0)
```
1   4   3
2   5   6
7   8   9
```

**Iteration (i=0, j=2):** Swap (0,2) ↔ (2,0)
```
1   4   7
2   5   6
3   8   9
```

**Iteration (i=1, j=2):** Swap (1,2) ↔ (2,1)
```
1   4   7
2   5   8
3   6   9
```

**After Transpose:**
```
1   4   7
2   5   8
3   6   9
```

### Step 2: Reverse Each Row

**Reverse Row 0:** [1, 4, 7] → [7, 4, 1]
```
7   4   1
2   5   8
3   6   9
```

**Reverse Row 1:** [2, 5, 8] → [8, 5, 2]
```
7   4   1
8   5   2
3   6   9
```

**Reverse Row 2:** [3, 6, 9] → [9, 6, 3]
```
7   4   1
8   5   2
9   6   3
```

**Final Result:** ✓ Correct 90° clockwise rotation!

---

## Edge Cases

### 1 × 1 Matrix
```
Input:  [5]
Output: [5]

No rotation needed - single element
```

### 2 × 2 Matrix
```
Input:
1  2
3  4

Transpose:
1  3
2  4

Reverse Rows:
3  1
4  2

Output:
3  1
4  2
```

### 5 × 5 Matrix
```
Works perfectly for any N × N matrix!
```

---

## Common Mistakes

❌ **Mistake 1: Transposing entire matrix (including lower triangle)**
```java
// WRONG - swaps elements twice!
for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
        swap(matrix[i][j], matrix[j][i]);
    }
}
```
**Why wrong?** Swaps (0,1)↔(1,0), then swaps back!

❌ **Mistake 2: Not starting j from i+1**
```java
// WRONG - includes diagonal
for(int i = 0; i < n; i++) {
    for(int j = i; j < n; j++) {
        swap(matrix[i][j], matrix[j][i]);
    }
}
```
**Why wrong?** Swaps diagonal elements with themselves (unnecessary)

❌ **Mistake 3: Reversing columns instead of rows**
```java
// WRONG - this gives 90° counter-clockwise!
transpose();
reverseColumns();  // Wrong direction!
```

✅ **Correct:**
```java
for(int i = 0; i < n-1; i++) {       // Upper triangle only
    for(int j = i+1; j < n; j++) {    // Start from i+1
        swap(matrix[i][j], matrix[j][i]);
    }
}
// Then reverse each ROW (not column)
```

---

## Rotate Counter-Clockwise

**Question:** What if we want 90° **counter-clockwise** rotation?

**Answer:** Reverse the order of operations!

### Method 1: Transpose + Reverse Columns
```java
public void rotateCounterClockwise(int[][] matrix) {
    int n = matrix.length;
    
    // Step 1: Transpose
    transpose(matrix);
    
    // Step 2: Reverse each COLUMN (not row)
    reverseColumns(matrix);
}

private void reverseColumns(int[][] matrix) {
    int n = matrix.length;
    for(int j = 0; j < n; j++) {
        int top = 0, bottom = n-1;
        while(top < bottom) {
            int temp = matrix[top][j];
            matrix[top][j] = matrix[bottom][j];
            matrix[bottom][j] = temp;
            top++;
            bottom--;
        }
    }
}
```

### Method 2: Reverse Rows + Transpose
```java
public void rotateCounterClockwise(int[][] matrix) {
    int n = matrix.length;
    
    // Step 1: Reverse each row
    for(int i = 0; i < n; i++) {
        reverseRow(matrix[i]);
    }
    
    // Step 2: Transpose
    transpose(matrix);
}
```

---

## Approach Comparison

| Approach | Time | Space | In-Place? |
|----------|------|-------|-----------|
| Brute Force (Extra Matrix) | O(N²) | O(N²) | ❌ No |
| Optimal (Transpose + Reverse) | O(N²) | O(1) | ✅ Yes |

**Space Improvement:** O(N²) → O(1) = **Massive improvement!**

---

## Key Takeaways

1. **Rotation = Transpose + Reverse**
   - 90° Clockwise: Transpose + Reverse Rows
   - 90° Counter-Clockwise: Transpose + Reverse Columns

2. **Transpose In-Place:**
   - Only traverse upper triangle
   - Start j from i+1 to avoid diagonal and duplicates

3. **Reverse Row:**
   - Two-pointer approach
   - Swap first with last, move inward

4. **Space Optimization:**
   - No extra matrix needed
   - All operations in-place

5. **Time Complexity:**
   - Still O(N²) (unavoidable - must touch every element)
   - But space improved from O(N²) to O(1)

---

## Interview Tips

1. **Start with brute force:**
   - "I can use extra matrix, formula: (i,j) → (j, n-1-i)"

2. **Mention space issue:**
   - "This uses O(N²) space, can we do better?"

3. **Present optimal approach:**
   - "Observe: columns become reversed rows"
   - "Solution: Transpose + Reverse each row"

4. **Draw diagram:**
   - Show original → transposed → final
   - Helps interviewer follow your logic

5. **Code cleanly:**
   - Separate transpose and reverse functions
   - Use meaningful variable names

6. **Verify with example:**
   - Walk through 3×3 matrix step-by-step

This problem tests your ability to **optimize space** and **find patterns** in matrix transformations!