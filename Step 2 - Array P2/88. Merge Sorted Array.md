# Merge Two Sorted Arrays Without Extra Space

## Problem Statement

Given two **sorted arrays**, merge them **without using extra space**.

**Important:** Both arrays are already sorted individually.

### Task

Rearrange elements so that:
- First array contains the **smallest elements** in sorted order
- Second array contains the **largest elements** in sorted order

### Example

**Input:**
```
arr1 = [1, 3, 5, 7]  (size = 4)
arr2 = [0, 2, 6, 8, 9]  (size = 5)
```

**Merged version (conceptual):**
```
[0, 1, 2, 3, 5, 6, 7, 8, 9]
```

**Expected Output:**
```
arr1 = [0, 1, 2, 3]  (4 smallest elements)
arr2 = [5, 6, 7, 8, 9]  (5 largest elements)
```

**Important:** No third array should be created. Modify the given arrays in-place.

---

## Approach 1: Brute Force (Using Extra Space)

### Idea

1. Create a **third array** of size (n + m)
2. **Merge** both arrays into third array (like merge sort)
3. **Copy back** elements to original arrays

### Algorithm

**Step 1: Merge using two pointers**
```
arr1 = [1, 3, 5, 7]
arr2 = [0, 2, 6, 8, 9]

Use two pointers:
left = 0 (pointing to arr1)
right = 0 (pointing to arr2)
```

**Step 2: Compare and add to arr3**
```
Compare arr1[0]=1 vs arr2[0]=0
→ 0 is smaller, add to arr3
arr3 = [0, ...]

Compare arr1[0]=1 vs arr2[1]=2
→ 1 is smaller, add to arr3
arr3 = [0, 1, ...]

Compare arr1[1]=3 vs arr2[1]=2
→ 2 is smaller, add to arr3
arr3 = [0, 1, 2, ...]

... continue until all merged
arr3 = [0, 1, 2, 3, 5, 6, 7, 8, 9]
```

**Step 3: Copy back to original arrays**
```
First 4 elements (indices 0-3) → arr1
arr1 = [0, 1, 2, 3]

Remaining 5 elements (indices 4-8) → arr2
arr2[i-4] = arr3[i] for i from 4 to 8
arr2 = [5, 6, 7, 8, 9]
```

### Complete Walkthrough

**Initial:**
```
arr1 = [1, 3, 5, 7]
arr2 = [0, 2, 6, 8, 9]
arr3 = [_, _, _, _, _, _, _, _, _]  (size 9)

left = 0, right = 0, index = 0
```

**Iteration 1:**
```
arr1[0]=1 vs arr2[0]=0
→ 0 smaller
arr3[0] = 0, right++, index++
```

**Iteration 2:**
```
arr1[0]=1 vs arr2[1]=2
→ 1 smaller
arr3[1] = 1, left++, index++
```

**Iteration 3:**
```
arr1[1]=3 vs arr2[1]=2
→ 2 smaller
arr3[2] = 2, right++, index++
```

**Iteration 4:**
```
arr1[1]=3 vs arr2[2]=6
→ 3 smaller
arr3[3] = 3, left++, index++
```

**Iteration 5:**
```
arr1[2]=5 vs arr2[2]=6
→ 5 smaller
arr3[4] = 5, left++, index++
```

**Iteration 6:**
```
arr1[3]=7 vs arr2[2]=6
→ 6 smaller
arr3[5] = 6, right++, index++
```

**Iteration 7:**
```
arr1[3]=7 vs arr2[3]=8
→ 7 smaller
arr3[6] = 7, left++, index++
```

**Left exhausted! Add remaining from right:**
```
arr3[7] = 8
arr3[8] = 9
```

**Final arr3:**
```
arr3 = [0, 1, 2, 3, 5, 6, 7, 8, 9]
```

**Copy back:**
```
For i = 0 to 3:
  arr1[i] = arr3[i]
→ arr1 = [0, 1, 2, 3]

For i = 4 to 8:
  arr2[i-4] = arr3[i]
→ arr2 = [5, 6, 7, 8, 9]
```

### Code

```java
public class Solution {
    public void mergeBruteForce(int[] arr1, int[] arr2) {
        int n = arr1.length;
        int m = arr2.length;
        
        // Step 1: Create third array
        int[] arr3 = new int[n + m];
        
        int left = 0;   // Pointer for arr1
        int right = 0;  // Pointer for arr2
        int index = 0;  // Pointer for arr3
        
        // Step 2: Merge while both have elements
        while(left < n && right < m) {
            if(arr1[left] <= arr2[right]) {
                arr3[index++] = arr1[left++];
            } else {
                arr3[index++] = arr2[right++];
            }
        }
        
        // Step 3: Add remaining from arr1
        while(left < n) {
            arr3[index++] = arr1[left++];
        }
        
        // Step 4: Add remaining from arr2
        while(right < m) {
            arr3[index++] = arr2[right++];
        }
        
        // Step 5: Copy back to original arrays
        for(int i = 0; i < n + m; i++) {
            if(i < n) {
                arr1[i] = arr3[i];
            } else {
                arr2[i - n] = arr3[i];
            }
        }
    }
}
```

### Complexity Analysis

**Time Complexity:** O(N + M) + O(N + M) = **O(2(N + M))**
- Merging into arr3: O(N + M)
- Copying back: O(N + M)

**Space Complexity:** O(N + M)
- Extra array arr3

**Verdict:** ❌ Interviewer asks to optimize space

---

## Approach 2: Optimal Solution 1 (Two Pointers)

### Key Insight

**Observation:**
```
arr1 = [1, 3, 5, 7]
arr2 = [0, 2, 6, 8, 9]
           ↑           ↑
        largest     smallest
       in arr1     in arr2
```

**Key Insight:**
- **Largest in arr1** (7) should be on the **right side**
- **Smallest in arr2** (0) should be on the **left side**
- If largest_arr1 > smallest_arr2 → **Swap them!**

### Algorithm

**Step 1:** Compare last of arr1 with first of arr2
```
If arr1[last] > arr2[first]:
    Swap them
    Move pointers
Else:
    Stop (already in correct order)
```

**Step 2:** Sort both arrays individually

### Detailed Walkthrough

**Initial:**
```
arr1 = [1, 3, 5, 7]
               ↑
              left (last element)

arr2 = [0, 2, 6, 8, 9]
        ↑
      right (first element)
```

**Iteration 1:**
```
Compare: arr1[3]=7 vs arr2[0]=0
→ 7 > 0, SWAP!

arr1 = [1, 3, 5, 0]
arr2 = [7, 2, 6, 8, 9]

left--, right++
```

**Iteration 2:**
```
Compare: arr1[2]=5 vs arr2[1]=2
→ 5 > 2, SWAP!

arr1 = [1, 3, 2, 0]
arr2 = [7, 5, 6, 8, 9]

left--, right++
```

**Iteration 3:**
```
Compare: arr1[1]=3 vs arr2[2]=6
→ 3 < 6, STOP!
(Elements in correct relative positions)
```

**After swaps:**
```
arr1 = [1, 3, 2, 0]  (has all small elements, unsorted)
arr2 = [7, 5, 6, 8, 9]  (has all large elements, unsorted)
```

**Sort arr1:**
```
[1, 3, 2, 0] → [0, 1, 2, 3]
```

**Sort arr2:**
```
[7, 5, 6, 8, 9] → [5, 6, 7, 8, 9]
```

**Final:**
```
arr1 = [0, 1, 2, 3]
arr2 = [5, 6, 7, 8, 9]
```

### Why This Works

**After swapping:**
- All elements in arr1 ≤ All elements in arr2
- Guaranteed by the stopping condition

**After sorting:**
- arr1 sorted internally
- arr2 sorted internally
- Combined result is sorted!

### Code

```java
public class Solution {
    public void mergeOptimal1(int[] arr1, int[] arr2) {
        int n = arr1.length;
        int m = arr2.length;
        
        int left = n - 1;  // Last element of arr1
        int right = 0;     // First element of arr2
        
        // Step 1: Swap elements to correct arrays
        while(left >= 0 && right < m) {
            if(arr1[left] > arr2[right]) {
                // Swap
                int temp = arr1[left];
                arr1[left] = arr2[right];
                arr2[right] = temp;
                
                left--;
                right++;
            } else {
                // Already in correct position
                break;
            }
        }
        
        // Step 2: Sort both arrays
        Arrays.sort(arr1);
        Arrays.sort(arr2);
    }
}
```

### Complexity Analysis

**Time Complexity:** O(min(N,M)) + O(N log N) + O(M log M)

**Breakdown:**
- Swapping loop: O(min(N, M))
  - At most min(N, M) swaps
  - Stops when smaller array exhausted
- Sorting arr1: O(N log N)
- Sorting arr2: O(M log M)
- **Total:** Dominated by sorting = **O(N log N + M log M)**

**Space Complexity:** O(1)
- No extra space (sorting is in-place)

---

## Approach 3: Optimal Solution 2 (Gap Method)

### Intuition

Uses **Shell Sort's gap method** concept.

### Algorithm

**Step 1:** Calculate initial gap
```
gap = ceil((n + m) / 2)
```

**Step 2:** Compare elements gap distance apart
```
left = 0
right = left + gap

While right < (n + m):
    Compare arr[left] with arr[right]
    If arr[left] > arr[right]: Swap
    Move both pointers
```

**Step 3:** Reduce gap and repeat
```
gap = ceil(gap / 2)
Repeat until gap = 1
```

**Step 4:** Stop when gap becomes 1 and iteration completes

### Gap Calculation

```
Length = n + m = 4 + 5 = 9

Initial gap = ceil(9 / 2) = ceil(4.5) = 5

Gap sequence:
5 → ceil(5/2) = 3
3 → ceil(3/2) = 2  
2 → ceil(2/2) = 1
1 → STOP after this iteration
```

**Formula in code:**
```java
gap = (length / 2) + (length % 2)
```

### Detailed Walkthrough

**Arrays:**
```
arr1 = [1, 3, 5, 7]
arr2 = [0, 2, 6, 8, 9]

Combined view (for understanding):
Index: 0  1  2  3  4  5  6  7  8
Value: 1  3  5  7  0  2  6  8  9
       └────arr1───┘ └─────arr2─────┘
```

### Gap = 5

**Pointers:**
```
left=0, right=5
```

**Iteration 1:**
```
Compare arr[0]=1 with arr[5]=2
→ 1 < 2, no swap
left++, right++
```

**Iteration 2:**
```
Compare arr[1]=3 with arr[6]=6
→ 3 < 6, no swap
left++, right++
```

**Iteration 3:**
```
Compare arr[2]=5 with arr[7]=8
→ 5 < 8, no swap
left++, right++
```

**Iteration 4:**
```
Compare arr[3]=7 with arr[8]=9
→ 7 < 9, no swap
left++, right++
```

**Right crosses boundary, gap iteration done**

### Gap = 3

**Reset pointers:**
```
left=0, right=3
```

**Iteration 1:**
```
Compare arr[0]=1 with arr[3]=7
→ 1 < 7, no swap
left++, right++
```

**Iteration 2:**
```
Compare arr[1]=3 with arr[4]=0
→ 3 > 0, SWAP!

After swap:
arr1 = [1, 0, 5, 7]
arr2 = [3, 2, 6, 8, 9]

Combined: 1  0  5  7  3  2  6  8  9
```

**Iteration 3:**
```
Compare arr[2]=5 with arr[5]=2
→ 5 > 2, SWAP!

After swap:
arr1 = [1, 0, 2, 7]
arr2 = [3, 5, 6, 8, 9]

Combined: 1  0  2  7  3  5  6  8  9
```

**Iteration 4:**
```
Compare arr[3]=7 with arr[6]=6
→ 7 > 6, SWAP!

After swap:
arr1 = [1, 0, 2, 6]
arr2 = [3, 5, 7, 8, 9]

Combined: 1  0  2  6  3  5  7  8  9
```

**Continue...**

### Gap = 2

```
Compare elements 2 positions apart

After all swaps:
Combined: 0  1  2  3  5  6  7  8  9
```

### Gap = 1

```
Compare adjacent elements (like bubble sort pass)

Final:
arr1 = [0, 1, 2, 3]
arr2 = [5, 6, 7, 8, 9]
```

### Three Cases for Pointer Positions

**Case 1: Both in arr1**
```
left < n && right < n
Compare arr1[left] with arr1[right]
```

**Case 2: left in arr1, right in arr2**
```
left < n && right >= n
Compare arr1[left] with arr2[right-n]
```

**Case 3: Both in arr2**
```
left >= n && right >= n
Compare arr2[left-n] with arr2[right-n]
```

### Code

```java
public class Solution {
    public void mergeOptimal2(int[] arr1, int[] arr2) {
        int n = arr1.length;
        int m = arr2.length;
        int length = n + m;
        
        // Initial gap
        int gap = (length / 2) + (length % 2);
        
        while(gap > 0) {
            int left = 0;
            int right = left + gap;
            
            while(right < length) {
                // Case 1: Both in arr1
                if(left < n && right < n) {
                    swapIfGreater(arr1, arr1, left, right);
                }
                // Case 2: left in arr1, right in arr2
                else if(left < n && right >= n) {
                    swapIfGreater(arr1, arr2, left, right - n);
                }
                // Case 3: Both in arr2
                else {
                    swapIfGreater(arr2, arr2, left - n, right - n);
                }
                
                left++;
                right++;
            }
            
            // Break if gap is 1
            if(gap == 1) break;
            
            // Reduce gap
            gap = (gap / 2) + (gap % 2);
        }
    }
    
    private void swapIfGreater(int[] arr1, int[] arr2, int i, int j) {
        if(arr1[i] > arr2[j]) {
            int temp = arr1[i];
            arr1[i] = arr2[j];
            arr2[j] = temp;
        }
    }
}
```

### Complexity Analysis

**Time Complexity:** O((N + M) × log(N + M))

**Breakdown:**
- Gap sequence: log(N + M) iterations
  - 9 → 5 → 3 → 2 → 1 (logarithmic)
- Each gap iteration: O(N + M)
  - Traverse entire combined length
- **Total:** O((N + M) × log(N + M))

**Space Complexity:** O(1)
- No extra space used

---

## Complete Implementations

### Main Solution Class

```java
import java.util.*;

public class MergeSortedArrays {
    
    // Approach 1: Brute Force
    public void mergeBruteForce(int[] arr1, int[] arr2) {
        int n = arr1.length;
        int m = arr2.length;
        int[] arr3 = new int[n + m];
        
        int left = 0, right = 0, index = 0;
        
        // Merge
        while(left < n && right < m) {
            if(arr1[left] <= arr2[right]) {
                arr3[index++] = arr1[left++];
            } else {
                arr3[index++] = arr2[right++];
            }
        }
        
        while(left < n) arr3[index++] = arr1[left++];
        while(right < m) arr3[index++] = arr2[right++];
        
        // Copy back
        for(int i = 0; i < n + m; i++) {
            if(i < n) arr1[i] = arr3[i];
            else arr2[i - n] = arr3[i];
        }
    }
    
    // Approach 2: Optimal 1 (Two Pointers)
    public void mergeOptimal1(int[] arr1, int[] arr2) {
        int n = arr1.length;
        int m = arr2.length;
        int left = n - 1;
        int right = 0;
        
        while(left >= 0 && right < m) {
            if(arr1[left] > arr2[right]) {
                int temp = arr1[left];
                arr1[left] = arr2[right];
                arr2[right] = temp;
                left--;
                right++;
            } else {
                break;
            }
        }
        
        Arrays.sort(arr1);
        Arrays.sort(arr2);
    }
    
    // Approach 3: Optimal 2 (Gap Method)
    public void mergeOptimal2(int[] arr1, int[] arr2) {
        int n = arr1.length;
        int m = arr2.length;
        int length = n + m;
        int gap = (length / 2) + (length % 2);
        
        while(gap > 0) {
            int left = 0;
            int right = left + gap;
            
            while(right < length) {
                if(left < n && right < n) {
                    swapIfGreater(arr1, arr1, left, right);
                } else if(left < n && right >= n) {
                    swapIfGreater(arr1, arr2, left, right - n);
                } else {
                    swapIfGreater(arr2, arr2, left - n, right - n);
                }
                left++;
                right++;
            }
            
            if(gap == 1) break;
            gap = (gap / 2) + (gap % 2);
        }
    }
    
    private void swapIfGreater(int[] arr1, int[] arr2, int i, int j) {
        if(arr1[i] > arr2[j]) {
            int temp = arr1[i];
            arr1[i] = arr2[j];
            arr2[j] = temp;
        }
    }
    
    public static void main(String[] args) {
        MergeSortedArrays solution = new MergeSortedArrays();
        
        int[] arr1 = {1, 3, 5, 7};
        int[] arr2 = {0, 2, 6, 8, 9};
        
        System.out.println("Original:");
        System.out.println("arr1: " + Arrays.toString(arr1));
        System.out.println("arr2: " + Arrays.toString(arr2));
        
        solution.mergeOptimal2(arr1, arr2);
        
        System.out.println("\nAfter merging:");
        System.out.println("arr1: " + Arrays.toString(arr1));
        System.out.println("arr2: " + Arrays.toString(arr2));
    }
}
```

---

## Approach Comparison

| Approach | Time | Space | Method |
|----------|------|-------|--------|
| Brute Force | O(N+M) | O(N+M) | Extra array + merge |
| Optimal 1 | O(N log N + M log M) | O(1) | Two pointers + sort |
| Optimal 2 | O((N+M) log(N+M)) | O(1) | Gap method |

---

## Key Takeaways

1. **Brute Force:** Use extra space for merging
2. **Optimal 1:** Swap to partition, then sort
3. **Optimal 2:** Shell sort gap method
4. Both optimal solutions are acceptable in interviews
5. Space optimization: O(N+M) → O(1)

This problem tests your ability to **optimize space** while maintaining efficiency!