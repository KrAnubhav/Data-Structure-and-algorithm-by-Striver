# Find the Duplicate Number

## Problem Statement

Given an array of **N+1 integers** where every number is between **1 and N**, find the **duplicate number**.

**Assumptions:**
- Only **one duplicate number** exists
- The duplicate can appear **more than twice**

### Examples

**Example 1:**
```
Input: [1, 3, 4, 2, 2]
Output: 2

Explanation: 2 appears twice
```

**Example 2:**
```
Input: [3, 1, 3, 4, 2]
Output: 3

Explanation: 3 appears twice
```

---

## Approach 1: Naive (Sorting)

### Idea

1. **Sort** the array
2. **Traverse** and find where `arr[i] == arr[i+1]`
3. That's the duplicate!

### Algorithm

**Step 1: Sort**
```
Original: [1, 3, 4, 2, 2]
Sorted:   [1, 2, 2, 3, 4]
```

**Step 2: Find duplicate**
```
Compare arr[0]=1 with arr[1]=2? No
Compare arr[1]=2 with arr[2]=2? Yes! ✓
Return 2
```

### Why This Works

After sorting, duplicate elements are **adjacent**.

### Code

```java
import java.util.*;

public class Solution {
    public int findDuplicateNaive(int[] nums) {
        // Sort the array
        Arrays.sort(nums);
        
        // Find adjacent duplicates
        for(int i = 0; i < nums.length - 1; i++) {
            if(nums[i] == nums[i + 1]) {
                return nums[i];
            }
        }
        
        return -1;  // Should never reach here
    }
}
```

### Complexity Analysis

**Time Complexity:** O(N log N)
- Sorting takes O(N log N)
- Linear scan: O(N)
- Total: O(N log N)

**Space Complexity:** O(1)
- Sorting in-place (assuming built-in sort)

**Issue:** 
❌ Modifies/distorts the original array  
❌ O(N log N) time - can we do better?

---

## Approach 2: Better (Hashing/Frequency Array)

### Idea

Use a **frequency array** to track occurrences.

### Key Observation

Numbers are in range **[1, N]** and array size is **N+1**.

### Algorithm

**Given:** Array of size 10 (N+1 where N=9)
```
Index:  0  1  2  3  4  5  6  7  8  9
Array: [2, 5, 9, 6, 9, 3, 8, 9, 7, 1]
```

**Step 1:** Create frequency array of size N+1 (or 10)
```
Index: 0  1  2  3  4  5  6  7  8  9
Freq: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

**Step 2:** Traverse and update frequency

**Process arr[0] = 2:**
```
freq[2]++
Freq: [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]
```

**Process arr[1] = 5:**
```
freq[5]++
Freq: [0, 0, 1, 0, 0, 1, 0, 0, 0, 0]
```

**Process arr[2] = 9:**
```
freq[9]++
Freq: [0, 0, 1, 0, 0, 1, 0, 0, 0, 1]
```

**Process arr[3] = 6:**
```
freq[6]++
Freq: [0, 0, 1, 0, 0, 1, 1, 0, 0, 1]
```

**Process arr[4] = 9:**
```
freq[9] is already 1!
This means 9 is duplicate!
Return 9
```

### Code

```java
public class Solution {
    public int findDuplicateBetter(int[] nums) {
        int n = nums.length;
        
        // Create frequency array
        int[] freq = new int[n];
        
        // Traverse array
        for(int num : nums) {
            // Check if already seen
            if(freq[num] == 1) {
                return num;  // Duplicate found!
            }
            // Mark as seen
            freq[num] = 1;
        }
        
        return -1;  // Should never reach here
    }
}
```

### Complexity Analysis

**Time Complexity:** O(N)
- Single pass through array

**Space Complexity:** O(N)
- Frequency array of size N

**Improvement:** 
✅ Better time complexity O(N log N) → O(N)  
❌ Still uses O(N) extra space

---

## Approach 3: Optimal (Floyd's Cycle Detection)

### Key Insight

**Treat array as a linked list!**

```
Index:  0  1  2  3  4  5  6  7  8  9
Value: [2, 5, 9, 6, 3, ?, 8, 7, ?, 1]

Think of it as:
index 0 → points to index 2 (value at index 0 is 2)
index 2 → points to index 9 (value at index 2 is 9)
index 9 → points to index 1 (value at index 9 is 1)
...
```

**Key Property:** Since there's a duplicate, there **must be a cycle**!

### Why Cycle Exists?

```
Example: [1, 3, 4, 2, 2]

Index: 0  1  2  3  4
Value: 1  3  4  2  2

Graph representation:
0 → 1 → 3 → 2 → 4 → 2 (cycle!)
              ↑_____↓

Duplicate is 2, so index 3 and 4 both point to 2
This creates a cycle!
```

### Floyd's Tortoise and Hare Algorithm

**Two Phases:**

1. **Phase 1:** Detect cycle exists (find first collision)
2. **Phase 2:** Find cycle entry point (the duplicate)

### Detailed Walkthrough

**Array:** [2, 5, 9, 6, 9, 3, 8, 9, 7, 1]

**Build the "linked list":**
```
Start at index 0, value = 2
→ Go to index 2, value = 9
→ Go to index 9, value = 1
→ Go to index 1, value = 5
→ Go to index 5, value = 3
→ Go to index 3, value = 6
→ Go to index 6, value = 8
→ Go to index 8, value = 7
→ Go to index 7, value = 9
→ Go to index 9 (CYCLE!)
```

**Visual:**
```
2 → 9 → 1 → 5 → 3 → 6 → 8 → 7
    ↑_________________________↓
         Cycle formed!
```

### Phase 1: Find First Collision

**Initialize:**
```
slow = nums[0] = 2
fast = nums[nums[0]] = nums[2] = 9
```

**Iteration 1:**
```
slow moves 1 step: slow = nums[2] = 9
fast moves 2 steps: fast = nums[nums[9]] = nums[1] = 5
```

**Iteration 2:**
```
slow moves 1 step: slow = nums[9] = 1
fast moves 2 steps: fast = nums[nums[5]] = nums[3] = 6
```

**Iteration 3:**
```
slow moves 1 step: slow = nums[1] = 5
fast moves 2 steps: fast = nums[nums[6]] = nums[8] = 7
```

**Continue until collision...**

Eventually **slow == fast** (they meet inside cycle)

### Phase 2: Find Cycle Entry (Duplicate)

**After collision:**
```
1. Keep slow at collision point
2. Move fast back to start (nums[0])
3. Move BOTH one step at a time
4. Where they meet = duplicate number!
```

**Why this works?** (Mathematical Proof below)

### Mathematical Proof

**Setup:**
```
S = Starting point (index 0)
D = Duplicate (cycle entry point)
C = First collision point

Distance from S to D = x
Distance from D to C (inside cycle) = a - x
```

**Phase 1 Analysis:**

```
Slow travels: x + (a - x) = a
Fast travels: 2a (moves twice as fast)

Difference: 2a - a = a
```

**Key Insight:** The difference `a` is a **multiple of cycle length**

**Why?** 
- Fast catches slow inside cycle
- Fast laps slow by complete cycles
- So `a = k × cycle_length` for some integer k

**Phase 2 Analysis:**

```
Move fast to start (S)
Move both 1 step at a time

Fast travels: x (to reach D)
Slow travels: (a - x) + x = a

Since a = k × cycle_length,
Slow completes k full cycles and ends at D!

Therefore: They meet at D (the duplicate)!
```

**Visual Proof:**
```
     x         a - x
S -----→ D ----------→ C
         ↑____________↓
            Cycle

Fast at S moves x → reaches D
Slow at C moves (a-x) → reaches D (after going around cycle)
Since a is multiple of cycle length, slow ends exactly at D!
```

---

## Complete Code

```java
public class Solution {
    public int findDuplicate(int[] nums) {
        // Phase 1: Find collision point
        int slow = nums[0];
        int fast = nums[0];
        
        // Move until collision
        do {
            slow = nums[slow];           // Move 1 step
            fast = nums[nums[fast]];     // Move 2 steps
        } while(slow != fast);
        
        // Phase 2: Find cycle entry (duplicate)
        fast = nums[0];  // Reset fast to start
        
        while(slow != fast) {
            slow = nums[slow];  // Move 1 step
            fast = nums[fast];  // Move 1 step
        }
        
        return slow;  // or fast, both are duplicate
    }
    
    public static void main(String[] args) {
        Solution sol = new Solution();
        
        int[] nums1 = {1, 3, 4, 2, 2};
        System.out.println("Duplicate: " + sol.findDuplicate(nums1));
        // Output: 2
        
        int[] nums2 = {3, 1, 3, 4, 2};
        System.out.println("Duplicate: " + sol.findDuplicate(nums2));
        // Output: 3
    }
}
```

---

## Step-by-Step Dry Run

**Array:** [1, 3, 4, 2, 2]

### Phase 1: Detect Cycle

**Initialize:**
```
slow = nums[0] = 1
fast = nums[0] = 1
```

**First do-while iteration:**
```
slow = nums[1] = 3
fast = nums[nums[1]] = nums[3] = 2
```

**Second iteration:**
```
slow = nums[3] = 2
fast = nums[nums[2]] = nums[4] = 2
```

**Collision! slow == fast == 2**

### Phase 2: Find Duplicate

**Reset fast:**
```
fast = nums[0] = 1
slow = 2 (stays at collision)
```

**Iteration 1:**
```
slow = nums[2] = 4
fast = nums[1] = 3
```

**Iteration 2:**
```
slow = nums[4] = 2
fast = nums[3] = 2
```

**Meet at 2! Answer = 2**

---

## Why Not Create Actual Linked List?

**Question:** Why not explicitly create linked list nodes?

**Answer:** 
- **No need!** Array indices act as pointers
- `nums[i]` tells us "next node"
- Saves space and complexity

**Array as Linked List:**
```
Index:  0  1  2  3  4
Value: [1, 3, 4, 2, 2]

Linked List view:
Node 0 → Node 1 (because nums[0] = 1)
Node 1 → Node 3 (because nums[1] = 3)
Node 3 → Node 2 (because nums[3] = 2)
Node 2 → Node 4 (because nums[2] = 4)
Node 4 → Node 2 (because nums[4] = 2) ← Cycle!
```

---

## Edge Cases

### Case 1: Duplicate at Start
```
Input: [2, 2, 2, 2, 2]
Output: 2

All point to index 2, cycle immediately
```

### Case 2: Duplicate at End
```
Input: [1, 2, 3, 4, 4]
Output: 4

Indices 3 and 4 point to same place
```

### Case 3: Long Chain Before Cycle
```
Input: [2, 6, 4, 1, 3, 1, 5]
Output: 1

Long path before entering cycle
```

---

## Common Mistakes

❌ **Mistake 1: Starting slow and fast at different positions**
```java
// WRONG
slow = 0;
fast = 1;
```
**Why wrong?** Algorithm assumes both start at same position

❌ **Mistake 2: Using while instead of do-while for Phase 1**
```java
// WRONG - won't even enter loop
while(slow != fast) {
    slow = nums[slow];
    fast = nums[nums[fast]];
}
```
**Why wrong?** Initially slow == fast, loop never executes!

❌ **Mistake 3: Not resetting fast in Phase 2**
```java
// WRONG - doesn't reset fast
while(slow != fast) {
    slow = nums[slow];
    fast = nums[fast];
}
```
**Why wrong?** Fast needs to start from beginning!

✅ **Correct Pattern:**
```java
// Phase 1: do-while (both start same)
do {
    slow = nums[slow];
    fast = nums[nums[fast]];
} while(slow != fast);

// Phase 2: reset fast, then while loop
fast = nums[0];
while(slow != fast) {
    slow = nums[slow];
    fast = nums[fast];
}
```

---

## Complexity Analysis

### Optimal Solution

**Time Complexity:** O(N)
- Phase 1: O(N) - traverse until collision
- Phase 2: O(N) - find entry point
- Total: O(N)

**Space Complexity:** O(1)
- Only two pointers (slow, fast)
- No extra data structures

---

## Approach Comparison

| Approach | Time | Space | Modifies Array? |
|----------|------|-------|-----------------|
| Sorting | O(N log N) | O(1) | ✅ Yes |
| Hashing | O(N) | O(N) | ❌ No |
| Floyd's Cycle | O(N) | O(1) | ❌ No |

**Winner:** Floyd's Cycle Detection - O(N) time, O(1) space!

---

## Key Takeaways

1. **Array as Linked List:**
   - Use indices as pointers
   - nums[i] tells where to go next

2. **Duplicate Creates Cycle:**
   - Two indices pointing to same value
   - Forms cycle in "linked list"

3. **Floyd's Algorithm:**
   - **Phase 1:** Detect cycle exists
   - **Phase 2:** Find cycle entry (duplicate)

4. **Why It Works:**
   - Mathematical proof using distances
   - Fast travels 2x distance of slow
   - Meeting point math leads to duplicate

5. **Optimal Solution:**
   - O(N) time without extra space
   - Doesn't modify array
   - Elegant and efficient

---

## Interview Tips

1. **Start with approaches:**
   - "Sorting works but modifies array"
   - "Hashing works but uses O(N) space"
   - "Floyd's cycle is optimal"

2. **Explain the insight:**
   - "Treat array as linked list"
   - "Duplicate creates cycle"

3. **Two phases clearly:**
   - "First find collision"
   - "Then find entry point"

4. **Code carefully:**
   - Use do-while for phase 1
   - Reset fast before phase 2
   - Move both 1 step in phase 2

5. **Complexity:**
   - "O(N) time, O(1) space"
   - "No modifications to array"

This problem tests understanding of **cycle detection** and **mathematical reasoning**!