# Pascal's Triangle - Lecture Notes

## What is Pascal's Triangle?

Pascal's Triangle is a triangular array where:
- First row always has **1**
- Second row has **1** at start and end
- For middle elements: add the two numbers directly above

```
Row 1:              1
Row 2:            1   1
Row 3:          1   2   1
Row 4:        1   3   3   1
Row 5:      1   4   6   4   1
Row 6:    1   5  10  10   5   1
```

### How to Build Pascal's Triangle:

**Row 3:** `1  2  1`
- Start and end: 1
- Middle: 1 + 1 = 2

**Row 4:** `1  3  3  1`
- Start and end: 1
- Middle elements: 1+2=3, 2+1=3

**Row 5:** `1  4  6  4  1`
- Start and end: 1
- Middle elements: 1+3=4, 3+3=6, 3+1=4

**Row 6:** `1  5  10  10  5  1`
- Start and end: 1
- Middle elements: 1+4=5, 4+6=10, 6+4=10, 4+1=5

---

## Three Types of Problems

### Type 1: Given Row and Column, Find Element

**Problem:** Given R and C, return the element at that position

**Example:** R = 5, C = 3
```
Row 1:              1
Row 2:            1   1
Row 3:          1   2   1
Row 4:        1   3   3   1
Row 5:      1   4   6   4   1  ← 5th row, 3rd element = 6
```

**Answer:** 6

#### Formula Approach

**Formula:** `(R-1)C(C-1)`

For R=5, C=3:
- (5-1)C(3-1) = 4C2

**NCR Formula:**
```
nCr = n! / (r! × (n-r)!)
```

**Example:** 4C2
```
4C2 = 4! / (2! × 2!)
    = (4 × 3 × 2 × 1) / ((2 × 1) × (2 × 1))
    = 24 / 4
    = 6
```

#### Optimized NCR Calculation

**Shortcut Pattern:**

For `7C2`:
```
7C2 = 7! / (2! × 5!)
    = (7 × 6 × 5 × 4 × 3 × 2 × 1) / ((2 × 1) × (5 × 4 × 3 × 2 × 1))
    = (7 × 6) / (2 × 1)  ← Cancel out common terms
```

For `10C3`:
```
10C3 = (10 × 9 × 8) / (3 × 2 × 1)
```

**Key Observation:** If r goes r places (r × (r-1) × ... × 1), then n also goes r places from n

**Important:** Calculate as `(10/1) × (9/2) × (8/3)` to avoid overflow

#### Code for NCR

```java
public static long NCR(int n, int r) {
    long result = 1;
    
    for(int i = 0; i < r; i++) {
        result = result * (n - i);  // Numerator: n, n-1, n-2...
        result = result / (i + 1);   // Denominator: 1, 2, 3...
    }
    
    return result;
}
```

**Time Complexity:** O(r)  
**Space Complexity:** O(1)

**Solution for Type 1:**
```java
int element = NCR(R-1, C-1);
```

---

### Type 2: Print Any Nth Row

**Problem:** Given N, print the Nth row of Pascal's Triangle

**Example:** N = 5
```
Answer: 1  4  6  4  1
```

**Key Observation:** Nth row always has N elements

#### Brute Force Approach

Run loop from C=1 to N, use formula for each element:
```java
for(int C = 1; C <= N; C++) {
    System.out.print(NCR(N-1, C-1) + " ");
}
```

**Time Complexity:** O(N × R) - Not optimal!

#### Optimal Approach - Pattern Recognition

Let's analyze Row 6 (N=6):
```
Column:  0    1    2     3     4     5
Value:   1    5    10    10    5     1
```

**Using 0-based indexing for columns:**

```
Column 0: 1 (always)
Column 1: 1 × (5/1) = 5
Column 2: 5 × (4/2) = 10
Column 3: 10 × (3/3) = 10
Column 4: 10 × (2/4) = 5
Column 5: 5 × (1/5) = 1
```

**Pattern Formula:**
```
answer = answer × (N - column) / column
```

Where N = row number (6 for row 6)

**Breakdown:**
- Column 1: multiply by 5 (6-1), divide by 1
- Column 2: multiply by 4 (6-2), divide by 2
- Column 3: multiply by 3 (6-3), divide by 3
- Column 4: multiply by 2 (6-4), divide by 4
- Column 5: multiply by 1 (6-5), divide by 5

#### Code for Optimal Approach

```java
public static void generateRow(int N) {
    long answer = 1;
    System.out.print(answer + " ");  // First element is always 1
    
    for(int i = 1; i < N; i++) {
        answer = answer * (N - i);
        answer = answer / i;
        System.out.print(answer + " ");
    }
}
```

**Time Complexity:** O(N)  
**Space Complexity:** O(1)

---

### Type 3: Print Entire Pascal's Triangle

**Problem:** Given N, print entire Pascal's Triangle up to N rows

**Example:** N = 6
```
Output:
[1]
[1, 1]
[1, 2, 1]
[1, 3, 3, 1]
[1, 4, 6, 4, 1]
[1, 5, 10, 10, 5, 1]
```

#### Brute Force Approach

Use NCR formula for every element:
```java
for(int row = 1; row <= N; row++) {
    for(int col = 1; col <= row; col++) {
        System.out.print(NCR(row-1, col-1) + " ");
    }
    System.out.println();
}
```

**Time Complexity:** O(N × N × R) ≈ O(N³) - Too slow!

#### Optimal Approach

Use Type 2 solution to generate each row efficiently:

```cpp
List<Long> generateRow(int row) {
    List<Long> answerRow = new ArrayList<>();
    long answer = 1;
    answerRow.add(answer);  // First element
    
    for(int col = 1; col < row; col++) {
        answer = answer * (row - col);
        answer = answer / col;
        answerRow.add(answer);
    }
    
    return answerRow;
}

List<List<Long>> generate(int N) {
    List<List<Long>> answer = new ArrayList<>();
    
    for(int i = 1; i <= N; i++) {
        List<Long> temp = generateRow(i);
        answer.add(temp);
    }
    
    return answer;
}
```

**Time Complexity:** O(N²)  
- N rows, each row takes O(N) to generate
- Total: N × N = O(N²)

**Space Complexity:** O(1) auxiliary space (not counting output storage)

---

## Important Notes

### Data Type Choice
- Always use `long` to avoid overflow
- Numbers grow rapidly in Pascal's Triangle

### Code Quality Tips
1. Break code into functions for readability
2. Use meaningful function names (e.g., `generateRow`)
3. Maintain clean, modular code structure
4. Interviewers focus on code quality, not just correctness

### Key Formulas Summary

**Element at position (R, C):**
```
Element = (R-1)C(C-1)
```

**NCR Calculation:**
```
nCr = n! / (r! × (n-r)!)

Optimized: (n × (n-1) × ... × (n-r+1)) / (r × (r-1) × ... × 1)
```

**Row Generation Pattern:**
```
next_element = current_element × (row - col) / col
```

---

## Complexity Summary

| Type | Problem | Approach | Time | Space |
|------|---------|----------|------|-------|
| 1 | Find element at (R,C) | NCR formula | O(R) | O(1) |
| 2 | Print Nth row | Pattern multiplication | O(N) | O(1) |
| 3 | Print entire triangle | Generate each row | O(N²) | O(1) |

**Note:** Space complexity doesn't count the output storage as it's required for the answer.