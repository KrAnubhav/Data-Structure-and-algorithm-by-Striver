# Set Matrix Zeroes - Lecture Notes

## Problem Statement

Given an **N × M matrix** containing only 0s and 1s (binary matrix):
- Find all positions with 0
- For each 0 found, mark the entire row and column as 0
- Return the modified matrix

**Important:** Only process zeros that exist in the **initial matrix**, not zeros created during marking.

### Example

**Input Matrix:**
```
1  1  1  1
1  0  1  1
1  1  0  1
0  1  1  1
```

**Process:**
- Zero at position (1,1) → Mark row 1 and column 1
- Zero at position (2,2) → Mark row 2 and column 2  
- Zero at position (3,0) → Mark row 3 and column 0

**Output Matrix:**
```
0  1  0  0
0  0  0  0
0  0  0  0
0  0  0  0
```

---

## Approach 1: Brute Force

### Key Idea
Cannot directly mark zeros because newly created zeros will incorrectly trigger more marking. Solution: Use **-1** as a temporary marker.

### Algorithm

1. Traverse the matrix
2. When you find a 0:
   - Mark all **non-zero** elements in that row as -1
   - Mark all **non-zero** elements in that column as -1
3. After traversal, convert all -1s to 0s

**Important:** Do NOT mark existing zeros as -1, as they need to trigger their own marking.

### Step-by-Step Example

**Initial Matrix:**
```
1  1  1  1
1  0  1  1
1  1  0  1
0  1  1  1
```

**Step 1:** Found 0 at (1,1)
```
1   -1   1   1
-1   0  -1  -1
1   -1   0   1
0   -1   1   1
```

**Step 2:** Found 0 at (2,2)
```
1   -1  -1   1
-1   0  -1  -1
-1  -1   0  -1
0   -1  -1   1
```

**Step 3:** Found 0 at (3,0)
```
1   -1  -1   1
-1   0  -1  -1
-1  -1   0  -1
0   -1  -1  -1
```

**Step 4:** Convert all -1 to 0
```
0  0  0  1
0  0  0  0
0  0  0  0
0  0  0  0
```

### Code

```java
public class Solution {
    
    // Mark entire row as -1 (except zeros)
    public static void markRow(int[][] matrix, int n, int m, int row) {
        for(int j = 0; j < m; j++) {
            if(matrix[row][j] != 0) {
                matrix[row][j] = -1;
            }
        }
    }
    
    // Mark entire column as -1 (except zeros)
    public static void markColumn(int[][] matrix, int n, int m, int col) {
        for(int i = 0; i < n; i++) {
            if(matrix[i][col] != 0) {
                matrix[i][col] = -1;
            }
        }
    }
    
    public static void setZeroes(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        
        // Step 1: Mark rows and columns with -1
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(matrix[i][j] == 0) {
                    markRow(matrix, n, m, i);
                    markColumn(matrix, n, m, j);
                }
            }
        }
        
        // Step 2: Convert all -1 to 0
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(matrix[i][j] == -1) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

### Complexity Analysis

**Time Complexity:** O(N × M) × (N + M) ≈ **O(N³)** or **O(M³)**
- Outer loops: O(N × M) to traverse matrix
- For each 0 found: O(N + M) to mark row and column
- Final conversion: O(N × M)

**Space Complexity:** O(1)
- No extra space used (in-place modification)

**Issue:** O(N³) time complexity - interviewer won't accept this!

---

## Approach 2: Better Solution (Using Hash Arrays)

### Key Idea
Instead of marking entire row/column immediately, use **hash arrays** to track which rows and columns need to be zeroed.

### Intuition

For any element to be 0 in final matrix:
- **Either** its row contains at least one 0
- **Or** its column contains at least one 0

We can track this using:
- `row[]` array of size N
- `col[]` array of size M

### Algorithm

1. Create `row[N]` and `col[M]` arrays, initialize all to 0
2. Traverse matrix:
   - If `matrix[i][j] == 0`:
     - Mark `row[i] = 1`
     - Mark `col[j] = 1`
3. Traverse matrix again:
   - If `row[i] == 1` OR `col[j] == 1`:
     - Set `matrix[i][j] = 0`

### Visual Example

**Initial Matrix:**
```
1  1  1  1
1  0  1  1
1  1  0  1
0  1  1  1
```

**Hash Arrays:**
```
row[]:  0  0  0  0  (initially)
col[]:  0  0  0  0  (initially)
```

**After marking zeros:**
```
Position (1,1) → row[1]=1, col[1]=1
Position (2,2) → row[2]=1, col[2]=1
Position (3,0) → row[3]=1, col[0]=1

row[]:  0  1  1  1
col[]:  1  1  1  0
```

**Final conversion:**
```
For (0,0): row[0]=0, col[0]=1 → col marked → 0
For (0,1): row[0]=0, col[1]=1 → col marked → 0
For (0,2): row[0]=0, col[2]=1 → col marked → 0
For (0,3): row[0]=0, col[3]=0 → not marked → 1
... and so on
```

**Result:**
```
0  0  0  1
0  0  0  0
0  0  0  0
0  0  0  0
```

### Code

```java
public class Solution {
    public static void setZeroes(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        
        // Step 1: Create hash arrays
        int[] row = new int[n];
        int[] col = new int[m];
        
        // Step 2: Mark rows and columns
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(matrix[i][j] == 0) {
                    row[i] = 1;
                    col[j] = 1;
                }
            }
        }
        
        // Step 3: Update matrix based on marks
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(row[i] == 1 || col[j] == 1) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

### Complexity Analysis

**Time Complexity:** O(N × M) + O(N × M) = **O(2 × N × M)** ≈ **O(N × M)**
- First traversal: O(N × M) for marking
- Second traversal: O(N × M) for updating

**Space Complexity:** O(N) + O(M)
- row[] array: O(N)
- col[] array: O(M)

**Issue:** Using extra space - interviewer asks to optimize!

---

## Approach 3: Optimal Solution (In-Place)

### Key Idea
Use the **first row and first column** of the matrix itself as hash arrays, eliminating extra space.

### Intuition

Instead of external arrays:
- Use `matrix[i][0]` as the row marker (first column)
- Use `matrix[0][j]` as the column marker (first row)

**Problem:** Position (0,0) is shared between row and column markers!

**Solution:** 
- Use `matrix[0][...]` for row markers
- Use `matrix[...][0]` for column markers (except [0][0])
- Use separate variable `col0` for column 0 marker

### Visual Representation

```
     col0 variable
        ↓
    [ (0,0)  0th row markers... ]  ← Row markers
    [   |                        ]
    [   |    Main matrix         ]
    [   |                        ]
    [   ↓                        ]
    Column markers
```

**Key Points:**
1. `matrix[0][0]` represents row 0
2. `col0` variable represents column 0
3. This avoids collision at (0,0)

### Important Edge Case

**Matrix that will be fully converted:**
```
1  1  1
0  1  1
1  0  1
```

After marking:
```
0  1  0  ← Row markers
0  1  1
0  0  1
↑
Column markers (including col0)
```

**Notice:** Only `matrix[0][0]` is NOT converted in the final answer!

All other elements will be 0 because:
- This 0 → marks entire column and row
- This 0 → marks entire column and row  
- This 0 → marks entire column and row

### Algorithm

**Step 1:** Mark using first row and column
```java
for(int i = 0; i < n; i++) {
    for(int j = 0; j < m; j++) {
        if(matrix[i][j] == 0) {
            matrix[i][0] = 0;  // Mark row
            if(j != 0) {
                matrix[0][j] = 0;  // Mark column (avoid collision)
            } else {
                col0 = 0;  // Separate marker for column 0
            }
        }
    }
}
```

**Step 2:** Update matrix (AVOID first row and column for now!)

Start from (1,1) to (n-1, m-1):
```
Why? If we change first row/column values now, they'll affect 
other elements incorrectly since they're being used as markers.
```

```java
for(int i = 1; i < n; i++) {
    for(int j = 1; j < m; j++) {
        if(matrix[i][j] != 0) {
            if(matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }
}
```

**Step 3:** Handle first row (depends on matrix[0][0])
```java
if(matrix[0][0] == 0) {
    for(int j = 0; j < m; j++) {
        matrix[0][j] = 0;
    }
}
```

**Step 4:** Handle first column (depends on col0)
```java
if(col0 == 0) {
    for(int i = 0; i < n; i++) {
        matrix[i][0] = 0;
    }
}
```

**Order is critical:** Handle inner matrix → first row → first column

### Complete Code

```java
public class Solution {
    public static void setZeroes(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int col0 = 1;  // Marker for column 0
        
        // Step 1: Mark using first row and first column
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(matrix[i][j] == 0) {
                    // Mark row i
                    matrix[i][0] = 0;
                    
                    // Mark column j
                    if(j != 0) {
                        matrix[0][j] = 0;
                    } else {
                        col0 = 0;
                    }
                }
            }
        }
        
        // Step 2: Mark inner matrix (avoid first row/column)
        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                if(matrix[i][j] != 0) {
                    // Check if row i or column j is marked
                    if(matrix[i][0] == 0 || matrix[0][j] == 0) {
                        matrix[i][j] = 0;
                    }
                }
            }
        }
        
        // Step 3: Handle first row
        if(matrix[0][0] == 0) {
            for(int j = 0; j < m; j++) {
                matrix[0][j] = 0;
            }
        }
        
        // Step 4: Handle first column
        if(col0 == 0) {
            for(int i = 0; i < n; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

### Complexity Analysis

**Time Complexity:** O(N × M) + O(N × M) = **O(2 × N × M)** ≈ **O(N × M)**
- Marking phase: O(N × M)
- Update phase: O(N × M)

**Space Complexity:** O(1)
- Only one variable `col0` used
- Everything done in-place

---

## Why Order Matters in Step 2, 3, 4

### Dependency Analysis

**First Row depends on:** `matrix[0][0]`
**First Column depends on:** `col0`
**Inner matrix depends on:** First row AND first column markers

**Correct Order:**
1. ✅ Inner matrix (1,1) to (n-1, m-1)
2. ✅ First row (depends on matrix[0][0])  
3. ✅ First column (depends on col0)

**Wrong Order:**
If we process first row/column before inner matrix:
- Changing `matrix[0][j]` values affects inner matrix incorrectly
- Changing `matrix[i][0]` values affects inner matrix incorrectly

### Example of Wrong Order

If we process first column first:
```
Initial markers:
matrix[0][0] = 0
col0 = 0

If we set column 0 to all zeros first:
matrix[0][0] = 0
matrix[1][0] = 0
matrix[2][0] = 0

Now when processing inner matrix:
It sees matrix[1][0] = 0 and incorrectly zeros row 1!
```

---

## Approach Comparison

| Approach | Time Complexity | Space Complexity | Accepted? |
|----------|----------------|------------------|-----------|
| Brute Force | O(N³) or O(M³) | O(1) | ❌ Too slow |
| Better (Hash) | O(N × M) | O(N + M) | ✅ But uses extra space |
| Optimal (In-place) | O(N × M) | O(1) | ✅✅ Best |

---

## Key Takeaways

1. **Brute Force:** Use -1 as temporary marker to avoid cascading zeros
2. **Better:** Use external hash arrays to track rows/columns
3. **Optimal:** Reuse first row/column as hash arrays
4. **Edge Case:** Handle (0,0) collision with separate variable
5. **Order Matters:** Process inner matrix before first row/column
6. **In-place optimization:** Think about using existing structure

---

## Common Mistakes to Avoid

❌ Directly marking zeros (creates cascading effect)
❌ Processing first row/column before inner matrix  
❌ Forgetting the col0 variable for collision at (0,0)
❌ Not handling the special case of matrix[0][0]
✅ Always process inner matrix first, then boundaries
✅ Use markers wisely to avoid data corruption